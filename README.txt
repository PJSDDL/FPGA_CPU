一个简单的16位CPU，指令数量少、消耗资源少，拥有堆栈栈与中断，可寻址64KB，无乘法和逻辑移位指令
开发板：STEP-FPGA（中文名小脚丫FPGA），MOX2版本
开发软件：Diamond


----------------------------------------------------------------------------------------------------------------------------------------
资源消耗：
51核：>1000LUT（LUT4）
picoRV32：>500LUT（LUT6）
该CPU：511LUT（LUT4）


----------------------------------------------------------------------------------------------------------------------------------------
使用方法：
1、在ASSEMBLY.txt中输入汇编代码，2、运行py脚本Assembler.py，3、打开工程，更新ram  ip核，4、仿真确认（仿真文件存放在CPU4/wave.do中）
另：若不使用中断功能，可以将`define    IRQ     1'b1这一语句删除，节约资源


----------------------------------------------------------------------------------------------------------------------------------------
汇编语言说明：
1）汇编器有以下作用：计算标签对应地址，将二进制数、十六进制数转化为12位二进制数，将操作码转换为二进制数，识别一些语法错误
2）汇编器语法注意：①标签必须以:结尾；②注释以//开头，不能有空格；③标签第一次出现时必须独立成段注释里不能有空格；④汇编语言必须以JMP  NUM指令开头（NUM为12位二进制数），NUM是中断后跳转到的地址，程序入口地址是0X002


----------------------------------------------------------------------------------------------------------------------------------------
CPU寄存器：
通用寄存器：A   B
堆栈指针：SP
程序计数器与计数器暂存器：PC与PC_temp
输出寄存器：P
输入寄存器：rx
标志寄存器：flag
中断允许：IRQ_EN

CPU指令表：
10000000_00000000：JMP，无条件跳转
00000000_00000001：JTA，跳转到A寄存器对应的位置
10000000_00000010：JB，寄存器A > 寄存器B，跳转到立即数对应的位置
10000000_00000011：JS，寄存器A < 寄存器B，跳转到立即数对应的位置
10000000_00000100：JE，寄存器A == 寄存器B，跳转到立即数对应的位置
10000000_00000101：MOVA，寄存器A = 立即数
00000000_00000110：保留
10000000_00000111：保留
00000000_00001000：保留
00000000_00001001：IN,寄存器A = {15'b0, rx}
10000000_00001010：MOVAP，寄存器A = 寄存器P，该指令不能读取IO，只能读取曾经写入IO的数据
00000000_00001011：PUSHB，寄存器B入栈
00000000_00001100：POPB，出栈，保存到寄存器B
00000000_00001101：OUT，寄存器P = 寄存器A
10000000_00001110：READA，读取内存数据到A寄存器，内存地址为立即数
10000000_00001111：SAVEA，保存A寄存器数据到内存，内存地址为立即数
00000000_00010000：READFB，读取内存数据到A寄存器，内存地址为寄存器B的值
00000000_00010001：SAVETB，保存A寄存器数据到内存，内存地址为寄存器B的值
00000000_00010010：PUSHA，寄存器A入栈
00000000_00010011：POPA，出栈，保存到寄存器A
00000000_00010100：SP，寄存器SP = 寄存器A
00000000_00010101：ADD，寄存器A = 寄存器A + 寄存器B
00000000_00010110：ADDB，寄存器B = 寄存器A + 寄存器B
00000000_00010111：AND，寄存器A = 寄存器A AND 寄存器B
00000000_00011000：OR，寄存器A = 寄存器A OR 寄存器B
00000000_00011001：NOT，寄存器A = NOT 寄存器A
00000000_00011010：ADDF，寄存器A = 寄存器A + 寄存器B + FLAG
00000000_00011011：RETI，结束中断程序，跳转回之前的位置
00000000_00011100：IEN，允许中断，中断由模块输入key的下降沿触发
00000000_00011101：保留
00000000_00011110：保留
00000000_00011110：保留

伪指令：
MOVB，将立即数移入B寄存器
RET，用于函数返回，出栈到寄存器A，并跳转到寄存器A对应地址
CALL，调用函数，将函数返回地址压入堆栈，然后跳转到函数位置，注意该指令不保存寄存器的值
PUSH，将寄存器A寄存器B入栈
POP，出栈两次，结果保存在寄存器B寄存器A
RL，寄存器A逻辑左移
READB，读取内存数据到B寄存器，内存地址为立即数
SETBIT，输出寄存器 = 寄存器A 或 输出寄存器
CLRBIT，输出寄存器 = 寄存器A 与 输出寄存器